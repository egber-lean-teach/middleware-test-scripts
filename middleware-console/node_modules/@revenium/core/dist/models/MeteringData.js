"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Metering = void 0;
const calculateDuration_1 = require("../utils/calculateDuration");
const formatTimeStamp_1 = require("../utils/formatTimeStamp");
const generateTransactionId_1 = require("../utils/generateTransactionId");
const Logger_1 = require("./Logger");
const constants_1 = require("../utils/constants/constants");
class Metering {
    constructor({ clientApiKey, baseUrl, type, } = {}) {
        var _a, _b;
        this.apiKey = (_a = clientApiKey !== null && clientApiKey !== void 0 ? clientApiKey : process.env.REVENIUM_METERING_API_KEY) !== null && _a !== void 0 ? _a : "";
        this.baseUrl = (_b = baseUrl !== null && baseUrl !== void 0 ? baseUrl : process.env.REVENIUM_METERING_BASE_URL) !== null && _b !== void 0 ? _b : "";
        this.type = type !== null && type !== void 0 ? type : "google";
    }
    createMeteringRequest(metering) {
        const agent = this.type === "google" ? constants_1.GOOGLE_AGENT : constants_1.VERTEXT_AGENT;
        return {
            stopReason: metering.stopReason,
            costType: constants_1.COST_TYPE,
            isStreamed: false,
            taskType: constants_1.COST_TYPE,
            agent,
            operationType: metering.operationType.toString(),
            inputTokenCount: metering.tokenCounts.inputTokens,
            outputTokenCount: metering.tokenCounts.outputTokens,
            reasoningTokenCount: metering.tokenCounts.reasoningTokens || 0,
            cacheCreationTokenCount: metering.tokenCounts.cachedTokens || 0,
            cacheReadTokenCount: 0,
            totalTokenCount: metering.tokenCounts.totalTokens,
            organizationId: `my-customer-name-${(0, generateTransactionId_1.generateTransactionId)()}`,
            productId: constants_1.PRODUCT_ID_FREE,
            subscriber: {
                id: `user-${(0, generateTransactionId_1.generateTransactionId)()}`,
                email: `user-@${agent.toLowerCase()}.ai`,
                credential: constants_1.CURRENT_CREDENTIAL,
            },
            model: metering.modelName,
            transactionId: (0, generateTransactionId_1.generateTransactionId)(),
            responseTime: (0, formatTimeStamp_1.formatTimestamp)(metering.endTime),
            requestDuration: (0, calculateDuration_1.calculateDurationMs)(metering.startTime, metering.endTime),
            provider: constants_1.PROVIDER_GOOGLE,
            requestTime: (0, formatTimeStamp_1.formatTimestamp)(metering.startTime),
            completionStartTime: (0, formatTimeStamp_1.formatTimestamp)(metering.endTime),
            timeToFirstToken: 0,
            middleware_source: constants_1.MIDDLEWARE_SOURCE,
        };
    }
    async sendMeteringData(meteringRequest) {
        const endpoint = `${this.baseUrl}/v2/ai/completions`;
        try {
            const response = await fetch(endpoint, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "x-api-key": this.apiKey,
                    accept: "application/json",
                },
                body: JSON.stringify(meteringRequest),
            });
            if (!response.ok) {
                const errorData = await (response === null || response === void 0 ? void 0 : response.text());
                Logger_1.logger.error(`Metering API request failed with status ${response.status} - ${errorData}`);
                return;
            }
            Logger_1.logger.info(`Metering data sent successfully to Revenium`);
        }
        catch (error) {
            Logger_1.logger.error(`Error to sent metering data ${error}`);
        }
    }
}
exports.Metering = Metering;
//# sourceMappingURL=MeteringData.js.map