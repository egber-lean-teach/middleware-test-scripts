import OpenAI from "openai";
import {
  models,
  PERPLEXITY_API_BASE_URL,
  PERPLEXITY_API_KEY,
  PERPLEXITY_API_KEY_INVALID_MESSAGE,
  PERPLEXITY_CLIENT_INITIALIZED_MESSAGE,
  PERPLEXITY_METERING_API_KEY_IS_NOT_SET_MESSAGE,
  PERPLEXITY_METERING_BASE_URL_IS_NOT_SET_MESSAGE,
  PERPLEXITY_REQUIRED_API_KEY_MESSAGE,
  REVENIUM_METERING_API_KEY,
  REVENIUM_METERING_BASE_URL,
} from "./utils";
import { logger } from "./models/Logger";
import { IChatCompletionRequest } from "./interfaces/chatCompletionRequest";
import { Metering } from "./models/Metering";
import { IOperationType } from "./interfaces/operation";
import { extractGoogleAITokenCounts } from "./utils/extractTokenCount";
import { RequestOptions } from "openai/internal/request-options";

export class PerplexityReveniumMiddleware {
  private client: OpenAI;
  private working: boolean = true;
  private modelName: string = "";
  constructor() {
    this.verifyEnv();
    this.client = new OpenAI({
      apiKey: PERPLEXITY_API_KEY,
      baseURL: PERPLEXITY_API_BASE_URL,
    });
    logger.info(PERPLEXITY_CLIENT_INITIALIZED_MESSAGE);
  }
  public getGenerativeModel(model: string) {
    this.modelName = model;
    if (!models.includes(model)) {
      throw new Error(`Model ${model} is not supported`);
    }
    return {
      createChatCompletion: this.chatCompletion,
      createChatCompletionStream: this.streamingChatCompletion,
      createEmbeddings: this.embeddings,
    };
  }

  private embeddings = async (
    _body: Omit<OpenAI.Embeddings.EmbeddingCreateParams, "model">,
    _options?: RequestOptions
  ) => {};

  private streamingChatCompletion = async (params: IChatCompletionRequest) => {
    const startTime: Date = new Date();
    try {
      const { usageMetadata, ...openaiParams } = params;
      const requestParams = {
        ...openaiParams,
        model: this.modelName,
      };
      const result = await this.client?.chat.completions.create({
        ...requestParams,
        stream: true,
      });
      if (!this.working) {
        logger.warning("Metering is not working. Check your configuration.");
        return result;
      }
      const tokenCounts = extractGoogleAITokenCounts(result);
      const endTime: Date = new Date();
      logger.info("Metering is working.");
      const metering = new Metering(
        REVENIUM_METERING_API_KEY ?? "",
        REVENIUM_METERING_BASE_URL ?? ""
      );
      const getMetering = metering.createMetering(
        {
          modelName: this.modelName,
          endTime,
          startTime,
          operationType: IOperationType.CHAT,
          stopReason: "END",
          tokenCounts,
          usageMetadata,
        },
        true
      );
      await metering.sendMeteringData(getMetering);
      return result;
    } catch (error) {
      throw error;
    }
  };

  private chatCompletion = async (params: IChatCompletionRequest) => {
    const startTime: Date = new Date();
    try {
      const { usageMetadata, ...openaiParams } = params;
      const requestParams = {
        ...openaiParams,
        model: this.modelName,
      };
      const result: OpenAI.Chat.Completions.ChatCompletion & {
        _request_id?: string | null | undefined;
      } = await this.client?.chat.completions.create({
        ...requestParams,
        stream: false,
      });
      if (!this.working) {
        logger.warning("Metering is not working. Check your configuration.");
        return result;
      }
      const tokenCounts = extractGoogleAITokenCounts(result);
      const endTime: Date = new Date();
      logger.info(" Metering is working.");
      const metering = new Metering(
        REVENIUM_METERING_API_KEY ?? "",
        REVENIUM_METERING_BASE_URL ?? ""
      );
      const getMetering = metering.createMetering(
        {
          modelName: this.modelName,
          endTime,
          startTime,
          operationType: IOperationType.CHAT,
          stopReason: "END",
          tokenCounts,
          usageMetadata,
        },
        false
      );
      await metering.sendMeteringData(getMetering);
      return result;
    } catch (error) {
      throw error;
    }
  };

  private verifyEnv(): void {
    if (!PERPLEXITY_API_KEY) {
      logger.error(PERPLEXITY_REQUIRED_API_KEY_MESSAGE);
      throw new Error(PERPLEXITY_REQUIRED_API_KEY_MESSAGE);
    }

    if (!PERPLEXITY_API_KEY.includes("pplx-")) {
      logger.error(PERPLEXITY_API_KEY_INVALID_MESSAGE);
      throw new Error(PERPLEXITY_API_KEY_INVALID_MESSAGE);
    }

    if (!REVENIUM_METERING_API_KEY) {
      logger.warning(PERPLEXITY_METERING_API_KEY_IS_NOT_SET_MESSAGE);
      this.working = false;
    }

    if (!REVENIUM_METERING_BASE_URL) {
      logger.warning(PERPLEXITY_METERING_BASE_URL_IS_NOT_SET_MESSAGE);
      this.working = false;
    }
  }
}
