import { IMeteringRequest } from "../interfaces/meteringRequest";
import { IMeteringResponse } from "../interfaces/meteringResponse";
import {
  COST_TYPE,
  CURRENT_CREDENTIAL,
  MIDDLEWARE_SOURCE,
  PRODUCT_ID_FREE,
  REVENIUM_METERING_API_KEY,
  REVENIUM_METERING_BASE_URL,
} from "../utils";
import { calculateDurationMs } from "../utils/calculateDurationMs";
import { formatTimestamp } from "../utils/formatTimestamp";
import { generateTransactionId } from "../utils/generateTransactionId";
import { logger } from "./Logger";

export class Metering {
  private endpoint: string = "";
  private apiKey: string = "";
  constructor(clientApiKey: string, clientEndpoint: string) {
    this.apiKey = clientApiKey;
    this.endpoint = clientEndpoint;
  }

  public createMetering(
    metering: IMeteringRequest,
    isStreamed: boolean
  ): IMeteringResponse {
    const usageMetadata = metering.usageMetadata;
    const agent: string = "perplexity";
    return {
      stopReason: usageMetadata?.stopReason ?? metering.stopReason,
      costType: COST_TYPE,
      isStreamed,
      taskType: COST_TYPE,
      agent: usageMetadata?.agent ?? agent,
      operationType:
        usageMetadata?.operationType ?? metering.operationType.toString(),
      inputTokenCount:
        usageMetadata?.inputTokenCount ?? metering.tokenCounts.inputTokens,
      outputTokenCount:
        usageMetadata?.outputTokenCount ?? metering.tokenCounts.outputTokens,
      reasoningTokenCount:
        usageMetadata?.reasoningTokenCount ??
        metering.tokenCounts.reasoningTokens ??
        0,
      cacheCreationTokenCount:
        usageMetadata?.cacheCreationTokenCount ??
        metering.tokenCounts.cachedTokens ??
        0,
      cacheReadTokenCount: usageMetadata?.cacheReadTokenCount ?? 0,
      totalTokenCount:
        usageMetadata?.totalTokenCount ?? metering.tokenCounts.totalTokens,
      organizationId:
        usageMetadata?.organizationId ??
        `my-customer-name-${generateTransactionId()}`,
      productId: usageMetadata?.productId ?? PRODUCT_ID_FREE,
      subscriber: {
        id: usageMetadata?.subscriberId ?? `user-${generateTransactionId()}`,
        email:
          usageMetadata?.subscriberEmail ?? `user-@${agent.toLowerCase()}.ai`,
        credential:
          usageMetadata?.subscriberCredentialName &&
          usageMetadata?.subscriberCredential
            ? {
                name: usageMetadata.subscriberCredentialName,
                value: usageMetadata.subscriberCredential,
              }
            : CURRENT_CREDENTIAL,
      },
      model: metering.modelName,
      transactionId: usageMetadata?.transactionId ?? generateTransactionId(),
      responseTime: formatTimestamp(metering.endTime),
      requestDuration: calculateDurationMs(
        metering.startTime,
        metering.endTime
      ),
      provider: agent,
      requestTime:
        usageMetadata?.requestTime?.toString() ??
        formatTimestamp(metering.startTime),
      completionStartTime:
        usageMetadata?.completionStartTime?.toString() ??
        formatTimestamp(metering.endTime),
      timeToFirstToken: usageMetadata?.timeToFirstToken ?? 0,
      middleware_source: MIDDLEWARE_SOURCE,
    };
  }

  public sendMeteringData = async (
    metering: IMeteringResponse
  ): Promise<void> => {
    try {
      const response = await fetch(`${this.endpoint}/v2/ai/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": this.apiKey,
          accept: "application/json",
        },
        body: JSON.stringify(metering),
      });
      if (!response.ok) {
        const errorData = await response?.text();
        logger.error(
          `Metering API request failed with status ${response.status} - ${errorData}`
        );
        return;
      }
      logger.info(`Metering data sent successfully to Revenium`);
    } catch (error: any) {
      logger.error(`Error to sent metering data ${error}`);
    }
  };
}
