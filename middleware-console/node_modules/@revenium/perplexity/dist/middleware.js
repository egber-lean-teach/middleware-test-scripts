"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerplexityReveniumMiddleware = void 0;
const openai_1 = __importDefault(require("openai"));
const utils_1 = require("./utils");
const Logger_1 = require("./models/Logger");
const Metering_1 = require("./models/Metering");
const operation_1 = require("./interfaces/operation");
const extractTokenCount_1 = require("./utils/extractTokenCount");
class PerplexityReveniumMiddleware {
    constructor() {
        this.working = true;
        this.modelName = "";
        this.embeddings = async (_body, _options) => { };
        this.streamingChatCompletion = async (params) => {
            var _a;
            const startTime = new Date();
            try {
                const { usageMetadata, ...openaiParams } = params;
                const requestParams = {
                    ...openaiParams,
                    model: this.modelName,
                };
                const result = await ((_a = this.client) === null || _a === void 0 ? void 0 : _a.chat.completions.create({
                    ...requestParams,
                    stream: true,
                }));
                if (!this.working) {
                    Logger_1.logger.warning("Metering is not working. Check your configuration.");
                    return result;
                }
                const tokenCounts = (0, extractTokenCount_1.extractGoogleAITokenCounts)(result);
                const endTime = new Date();
                Logger_1.logger.info("Metering is working.");
                const metering = new Metering_1.Metering(utils_1.REVENIUM_METERING_API_KEY !== null && utils_1.REVENIUM_METERING_API_KEY !== void 0 ? utils_1.REVENIUM_METERING_API_KEY : "", utils_1.REVENIUM_METERING_BASE_URL !== null && utils_1.REVENIUM_METERING_BASE_URL !== void 0 ? utils_1.REVENIUM_METERING_BASE_URL : "");
                const getMetering = metering.createMetering({
                    modelName: this.modelName,
                    endTime,
                    startTime,
                    operationType: operation_1.IOperationType.CHAT,
                    stopReason: "END",
                    tokenCounts,
                    usageMetadata,
                }, true);
                await metering.sendMeteringData(getMetering);
                return result;
            }
            catch (error) {
                throw error;
            }
        };
        this.chatCompletion = async (params) => {
            var _a;
            const startTime = new Date();
            try {
                const { usageMetadata, ...openaiParams } = params;
                const requestParams = {
                    ...openaiParams,
                    model: this.modelName,
                };
                const result = await ((_a = this.client) === null || _a === void 0 ? void 0 : _a.chat.completions.create({
                    ...requestParams,
                    stream: false,
                }));
                if (!this.working) {
                    Logger_1.logger.warning("Metering is not working. Check your configuration.");
                    return result;
                }
                const tokenCounts = (0, extractTokenCount_1.extractGoogleAITokenCounts)(result);
                const endTime = new Date();
                Logger_1.logger.info(" Metering is working.");
                const metering = new Metering_1.Metering(utils_1.REVENIUM_METERING_API_KEY !== null && utils_1.REVENIUM_METERING_API_KEY !== void 0 ? utils_1.REVENIUM_METERING_API_KEY : "", utils_1.REVENIUM_METERING_BASE_URL !== null && utils_1.REVENIUM_METERING_BASE_URL !== void 0 ? utils_1.REVENIUM_METERING_BASE_URL : "");
                const getMetering = metering.createMetering({
                    modelName: this.modelName,
                    endTime,
                    startTime,
                    operationType: operation_1.IOperationType.CHAT,
                    stopReason: "END",
                    tokenCounts,
                    usageMetadata,
                }, false);
                await metering.sendMeteringData(getMetering);
                return result;
            }
            catch (error) {
                throw error;
            }
        };
        this.verifyEnv();
        this.client = new openai_1.default({
            apiKey: utils_1.PERPLEXITY_API_KEY,
            baseURL: utils_1.PERPLEXITY_API_BASE_URL,
        });
        Logger_1.logger.info(utils_1.PERPLEXITY_CLIENT_INITIALIZED_MESSAGE);
    }
    getGenerativeModel(model) {
        this.modelName = model;
        if (!utils_1.models.includes(model)) {
            throw new Error(`Model ${model} is not supported`);
        }
        return {
            createChatCompletion: this.chatCompletion,
            createChatCompletionStream: this.streamingChatCompletion,
            createEmbeddings: this.embeddings,
        };
    }
    verifyEnv() {
        if (!utils_1.PERPLEXITY_API_KEY) {
            Logger_1.logger.error(utils_1.PERPLEXITY_REQUIRED_API_KEY_MESSAGE);
            throw new Error(utils_1.PERPLEXITY_REQUIRED_API_KEY_MESSAGE);
        }
        if (!utils_1.PERPLEXITY_API_KEY.includes("pplx-")) {
            Logger_1.logger.error(utils_1.PERPLEXITY_API_KEY_INVALID_MESSAGE);
            throw new Error(utils_1.PERPLEXITY_API_KEY_INVALID_MESSAGE);
        }
        if (!utils_1.REVENIUM_METERING_API_KEY) {
            Logger_1.logger.warning(utils_1.PERPLEXITY_METERING_API_KEY_IS_NOT_SET_MESSAGE);
            this.working = false;
        }
        if (!utils_1.REVENIUM_METERING_BASE_URL) {
            Logger_1.logger.warning(utils_1.PERPLEXITY_METERING_BASE_URL_IS_NOT_SET_MESSAGE);
            this.working = false;
        }
    }
}
exports.PerplexityReveniumMiddleware = PerplexityReveniumMiddleware;
